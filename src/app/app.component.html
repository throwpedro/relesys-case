<main class="wrapper">
  <p-accordion [activeIndex]="0">
    <p-accordionTab header="AGENDA">
      <pre>
    Go through cases 01-04(05)
    There is some overlap, shouldn't be a problem
    I have used angular as an example for most of the points
      </pre>
    </p-accordionTab>
    <p-accordionTab header="CASE 01 - WHAT IS GOOD FE-ARCHITECTURE?">
      <h4>Good front-end architecture ensures that the application is scalable, maintainable and performant</h4>
      <h4> - Sometimes it even behaves as intended</h4>
      <h3>
        Components
      </h3>
      <pre>
    What everyone got right
      - The fundamental building idea
      - it's the correct solution for front end

    My (current) favorite software principle <a href="https://htmx.org/essays/locality-of-behaviour/">Locality of behaviour</a>
      - ‚ÄúThe primary feature for easy maintenance is locality:
      Locality is that characteristic of source code that enables
      a programmer to understand that source by looking
      at only a small portion of it.‚Äù - Richard Gabriel(Patterns in software)

    The LoB Principle:
      The behaviour of a unit of code
      should be as obvious as possible by looking only at that unit of code

    Somewhat contrasting SOC(Separation of Concerns) and DRY(Don't Repeat Yourself)
      </pre>
      <hr />
      <h3>
        State management
      </h3>
      <pre>
    Server-state vs client-state(global and local)
      - off the shelf solutions - NgRx, tan stack query
      </pre>
      <img width="650px" src="fetchbad.png" alt="query" />
      <img width="650px" src="fetchgood.png" alt="query" />
      <br />
      <p>

        tan stack: refetch, caching, updates, polling, retry, dispose.
      </p>
      <img width="800px" src="tanstackquery.png" alt="query" />
      <hr />
      <h3>
        Scalability and maintainability
      </h3>

      <pre>
    Make sure (almost) everyone understands the architecture and code
    Stick to the rules of the framework
    Have a plan. No wild west coding. This should as widely as possible be solved with automation and tools.
    Thou shalt not make spaceships. Code for today, not for tomorrow.
      </pre>
    </p-accordionTab>
    <p-accordionTab header="CASE 02: APPLY THE RIGHT TOOLING">
      <h3>
        UI development
      </h3>
      <pre>
    Avoid bikeshedding
    Design system
    This includes reusable components like buttons, forms, typography, color schemes, and layouts
    Style guide
    Visual consistency, somewhat overlaps with the design system
      </pre>
      <hr />
      <h3>
        Code quality
      </h3>
      <h4>
        What is front end code quality?
      </h4>
      <pre>
    Linting - eslint, prettier, biome
    Testing - unit tests(components in isolation, visual regression), acceptence/end-to-end tests(does it actually work?)
    Accessibility - axe, lighthouse, WCAG guidelines, real users
    CI/CD - github actions, jenkins, gitlab, circleci, codebuild
     - Tests in CI
     - Lint in CI
     - Conventional commits
     - Basically, automate everything
    Performance - lighthouse, real users, look at the screen - IT IS NOT MICRO BENCHMARKS
    Maintainability - extendability, readability, scalability, simplicity - the folks over at HTMX knows what's up: <a href="https://grugbrain.dev/">grugbrain</a>
     - The apex predator of code is complexity.
       The more complex the code, the harder it is to maintain,
       the harder it is to extend, the harder it is to read,
       the harder it is to scale, the harder it is to understand.
      </pre>
      <h4>
        Libraries and frameworks can help us deal with these points
      </h4>
      <pre>
    Generally, lean into the standards
    Angular is opinionated. It's a good thing, leverage this to your advantage
    <a href="https://angular.dev/style-guide">Angular best practices</a>

    They already solved some of your problems:
        <a href="https://angular.dev/guide/di">dependency injection</a>
        <a href="https://angular.dev/essentials/components">components</a>
        <a href="https://angular.dev/guide/routing">routing</a>
        <a href="https://angular.dev/guide/testing">testing</a>
      </pre>
    </p-accordionTab>
    <p-accordionTab header="CASE 03: TEST AUTOMATION">
      <h3>
        Types of tests
      </h3>
      <pre>
    Unit tests - jest
    Component tests - jest, Angular Jasmine & Karma
    End-to-end / user acceptence tests - playwright, cypress, puppeteer
    Visual regression tests - percy

    TEST IN CI
      </pre>
    </p-accordionTab>
    <p-accordionTab header="CASE 04: TAKING THE LEAD">
      <h3>
        Initial steps
      </h3>
      <pre>
    Settle on tech, settle on approach(Angular?, ngUpgrade?, ionic?)
    Invovle the team
     - What is our wishes? What are we good at? What are we not good at?

    I'm imagining something along the lines of a github wiki or similar for the overwiev of the architecture
     - write-ups on choices
     - diagrams
     - snippets

    Do some tryouts and POCs
      Example:
      - We go with Angular 18
      - setup in existing anuglarJs env.
      - docker?
      - Try out ngUpgrade
        - Can we build?, Can we test?, Can we deploy?
      - Will the Angular 18 toolchain work.
        - Routing, state management(NgRx), internationalization, testing
        - The more plug and play the better. Having more technologies living side by side is already a challenge.
      </pre>
      <h3>
        Execution
      </h3>
      <pre>
    If possible let's try <a href="https://basecamp.com/shapeup">shapeup</a>
     - low-fi problem statements
     - six week cycles
     - lots of freedom when working on solutions

     DHH:
       <blockquote class="blockquote">
        It turns out that programmers are actually surprisingly good at delivering great software on
        time, if you leave the scope open to negotiation during development. You're not going to get
        exactly what you asked for, but you wouldn't want that anyway. Because what you asked for
        before you began building was based on the absolute worst understanding of the problem.
       </blockquote>

    Informed captains
      </pre>
      <h3>
        The team
      </h3>
      <pre>
    The overall architecture and direction of the project should be clear and aligned for everyone in the team.
      - Review PR's PROPERLY
        - Allocate time to do it
        - Understand the domain - no? - ask
        - Does it work? - no? - ask
        - Do you understand the code? - no? - ask
        - Do not allow broken windows: <a href="https://en.wikipedia.org/wiki/Broken_windows_theory">The broken windows theory</a>
        - We will likely have a <code class="italic">.github/pull_request_template.md</code> file
      - Do task check-ins and follow-ups
        - Before coding, grab a coworker and explain in broad strokes how you intend to solve the problem.
        - When encountering road-blocks, icebergs or unknown unknowns, grab a coworker.

    There is the possibility of doing something like daily standups, but I'm not a fan of them. They tend to be a waste of time.
    I'd much rather try to foster a culture of openness and communication.
      - It's okay to ask for help
      - Pair program or draw on the whiteboard
      - It's okay to ask for feedback
      - It's okay to be wrong, no one has all the answers, all the time
        </pre>
    </p-accordionTab>
    <p-accordionTab header="CASE 05: MISC">
      <pre>
    Why upgrade? - EOL, performance, security, pwa support, testing framework, find coworkers, future proofing (üòá)
    Upgrade incrementally vs big bang (ngUpgrade vs new 'easier' stack)
    Angular vs everything else
    pwa vs ionic vs native
    The true test of time, when no one is left
      </pre>
    </p-accordionTab>
    <p-accordionTab header="APPENDIX">
      <h3>
        The case - PDF
      </h3>
      <object data='pdf_case.pdf' type='application/pdf' width='100%' height='700px'>
      </object>
    </p-accordionTab>
  </p-accordion>
</main>